# -*- coding: utf-8 -*-
"""FastAPI Application and API Routes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GaJ-R4Yi8zMIZqN4gfzRGcSqbZD_jWxW
"""

# backend/app.py
# FastAPI application using asynchronous database operations (asyncpg).

import time
import os
import logging
from datetime import datetime
from fastapi import FastAPI, APIRouter, Request, HTTPException, Depends
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional

from .config import Config
from .db_connector import connect_db, disconnect_db, initialize_schema_and_seed_data, pool

# Configure logging for the FastAPI app
logging.basicConfig(level=logging.INFO)

# --- Pydantic Data Models ---

# Base model for data required to create/update an entry (for request body validation)
class TestEntryCreate(BaseModel):
    feature: str = Field(..., min_length=1)
    sub_feature: str = Field(..., min_length=1)
    test_case: str = Field(..., min_length=1)
    linked_issue: Optional[str] = None
    selenium_test: Optional[str] = None
    api_test: Optional[str] = None
    notes: Optional[str] = None
    status_edge: str
    status_chrome: str
    status_firefox: str

# Model representing the data retrieved from the database (for response validation)
class TestEntry(TestEntryCreate):
    id: int
    created_at: datetime
    updated_at: datetime

# --- FastAPI Initialization ---

app = FastAPI(
    title="LDQA Checklist API",
    description="Asynchronous API for managing QA test entries.",
    version="1.0.0"
)

# Configure CORS Middleware
# Allows the frontend to communicate with the API
app.add_middleware(
    CORSMiddleware,
    allow_origins=[Config.FRONTEND_ORIGIN] if Config.FRONTEND_ORIGIN != '*' else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Startup and Shutdown Events ---

@app.on_event("startup")
async def startup_event():
    """Connect to DB and initialize schema on startup."""
    await connect_db()
    # Initialize schema and seed data asynchronously
    await initialize_schema_and_seed_data()
    logging.info("FastAPI application started and DB ready.")


@app.on_event("shutdown")
async def shutdown_event():
    """Disconnect from DB on shutdown."""
    await disconnect_db()
    logging.info("FastAPI application shut down.")

# --- API Router ---
router = APIRouter(prefix="/api")

# Dependency to acquire and release a database connection for each request
async def get_connection():
    # Uses the global pool created in db_connector.py
    conn = await pool.acquire()
    try:
        yield conn
    finally:
        await pool.release(conn)

# --- CRUD Endpoints ---

@router.get("/entries", response_model=List[TestEntry])
async def get_all_entries(conn: asyncpg.Connection = Depends(get_connection)):
    """Fetches all test entries asynchronously."""
    query = 'SELECT * FROM test_entries ORDER BY id DESC'
    # conn.fetch executes the query and returns list of records
    entries = await conn.fetch(query)
    # Convert asyncpg Record objects to dict for Pydantic validation/response
    return [dict(entry) for entry in entries]


@router.post("/entries", response_model=TestEntry)
async def create_entry(entry_data: TestEntryCreate, conn: asyncpg.Connection = Depends(get_connection)):
    """Creates a new test entry asynchronously."""

    # Convert status underscores back to forward slashes for database storage
    status_edge = entry_data.status_edge.replace('_', '/')
    status_chrome = entry_data.status_chrome.replace('_', '/')
    status_firefox = entry_data.status_firefox.replace('_', '/')

    query = """
        INSERT INTO test_entries (
            feature, sub_feature, test_case, linked_issue, selenium_test, api_test, notes,
            status_edge, status_chrome, status_firefox
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING *;
    """
    try:
        # Use fetchrow to execute and retrieve the single resulting row
        new_entry = await conn.fetchrow(query,
            entry_data.feature, entry_data.sub_feature, entry_data.test_case,
            entry_data.linked_issue, entry_data.selenium_test, entry_data.api_test,
            entry_data.notes, status_edge, status_chrome, status_firefox
        )
        if new_entry:
            return dict(new_entry)
        raise HTTPException(status_code=500, detail="Failed to retrieve newly created entry.")
    except Exception as e:
        logging.error(f"Database error during creation: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {e}")


@router.put("/entries/{entry_id}", response_model=TestEntry)
async def update_entry(entry_id: int, entry_data: TestEntryCreate, conn: asyncpg.Connection = Depends(get_connection)):
    """Updates an existing test entry by ID asynchronously."""

    set_clauses = []
    values = []

    # Get only the fields explicitly set in the request body
    update_fields = entry_data.dict(exclude_unset=True)

    # Build the dynamic UPDATE query using positional arguments ($1, $2, ...)
    placeholder_counter = 1

    for key, value in update_fields.items():
        if key.startswith('status_'):
            value = value.replace('_', '/')

        set_clauses.append(f"{key} = ${placeholder_counter}")
        values.append(value)
        placeholder_counter += 1

    set_clauses.append("updated_at = NOW()") # Update timestamp automatically

    if not set_clauses:
        raise HTTPException(status_code=400, detail="No valid fields to update")

    values.append(entry_id) # The ID is the final argument for the WHERE clause

    query = f"UPDATE test_entries SET {', '.join(set_clauses)} WHERE id = ${placeholder_counter} RETURNING *"

    try:
        updated_entry = await conn.fetchrow(query, *values)

        if updated_entry is None:
            raise HTTPException(status_code=404, detail="Entry not found")

        return dict(updated_entry)
    except Exception as e:
        logging.error(f"Database error during update: {e}")
        raise HTTPException(status_code=500, detail=f"Database error: {e}")


@router.delete("/entries/{entry_id}", status_code=200)
async def delete_entry(entry_id: int, conn: asyncpg.Connection = Depends(get_connection)):
    """Deletes a test entry by ID asynchronously."""
    query = "DELETE FROM test_entries WHERE id = $1"

    try:
        result = await conn.execute(query, entry_id)
        if result == 'DELETE 0':
            raise HTTPException(status_code=404, detail="Entry not found")
        return {"message": f"Entry {entry_id} deleted successfully"}
    except Exception as e:
        logging.error(f"Database error during deletion: {e}")
        raise HTTPException(status_code=500, detail="Database error")


@router.post("/jira/create")
async def create_jira_issue_placeholder(entry_ids: List[int], conn: asyncpg.Connection = Depends(get_connection)):
    """Placeholder endpoint to simulate JIRA issue creation for selected entries."""
    if not entry_ids:
        raise HTTPException(status_code=400, detail="No entries selected for JIRA creation.")

    # Fetch entries details for simulation
    entries = await conn.fetch('SELECT * FROM test_entries WHERE id = ANY($1::int[])', entry_ids)

    simulated_tickets = []

    # Use an asynchronous transaction for atomicity
    async with conn.transaction():
        for entry in entries:
            # Simulation: generate a ticket key and update the database
            simulated_key = f"LDQA-{entry['id']}-{int(time.time()) % 1000}"
            simulated_tickets.append({
                "entry_id": entry['id'],
                "ticket_key": simulated_key,
                "status": "Created"
            })

            # Update the original test entry with the new simulated JIRA link
            await conn.execute("UPDATE test_entries SET linked_issue = $1, updated_at = NOW() WHERE id = $2",
                               simulated_key, entry['id'])

    return {
        "message": f"Successfully simulated JIRA issue creation for {len(entries)} entries.",
        "results": simulated_tickets,
        "jira_server_url": Config.JIRA_BASE_URL
    }

# Register the API router
app.include_router(router)

# --- Serve Frontend File ---
# Serve the static frontend files (CSS) from the 'frontend' directory
app.mount("/frontend", StaticFiles(directory="frontend"), name="frontend_static")

@app.get("/", response_class=HTMLResponse)
async def serve_index():
    """Serves the main index.html file."""
    # Read and return the HTML file content
    try:
        with open("frontend/index.html", 'r') as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Frontend file not found.")

# Main entry point for the application, executed by Uvicorn
# if __name__ == '__main__':
#     import uvicorn
#     uvicorn.run("backend.app:app", host="0.0.0.0", port=5000, reload=True)